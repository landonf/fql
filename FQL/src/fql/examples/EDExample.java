package fql.examples;

public class EDExample extends Example {

	@Override
	public String getName() {
		return "FO ED";
	}

	@Override
	public String getText() {
		return s;
	}

	String s = "schema S = {"
+ "\nnodes S;"
+ "\nattributes;"
+ "\narrows;"
+ "\nequations;"
+ "\n}"
+ "\n"
+ "\nschema T = {"
+ "\nnodes T1, T2;"
+ "\nattributes;"
+ "\narrows f : T1 -> T2;"
+ "\nequations;"
+ "\n}"
+ "\n"
+ "\nmapping F : S -> T = {"
+ "\nnodes S -> T1;"
+ "\nattributes;"
+ "\narrows;"
+ "\n}"
+ "\n"
+ "\ninstance I : S = {"
+ "\nnodes S -> {1,2,3};"
+ "\nattributes;"
+ "\narrows;"
+ "\n}"
+ "\n"
+ "\ninstance J : T = pi F I"
+ "\n/*"
+ "\nJ is"
+ "\ninstance J : T = {"
+ "\nnodes"
+ "\nT2 -> { 4 },"
+ "\nT1 -> { 6, 7, 5 }"
+ "\n ;"
+ "\nattributes"
+ "\n"
+ "\n ;"
+ "\narrows"
+ "\nf -> { (6,4), (5,4), (7,4) };"
+ "\n}"
+ "\n*/"
+ "\n"
+ "\ninstance K : T = SIGMA F I"
+ "\n/*"
+ "\ninstance K : T = {"
+ "\nnodes"
+ "\nT2 -> { 24, 22, 23 },"
+ "\nT1 -> { 25, 27, 26 }"
+ "\n ;"
+ "\nattributes"
+ "\n"
+ "\n ;"
+ "\narrows"
+ "\nf -> { (27,24), (25,23), (26,22) };"
+ "\n}"
+ "\n*/";

	
//	String s = "/* "
//			+ "\n"
//			+ "\nS has one unary relation, Emp"
//			+ "\n"
//			+ "\nX has one binary relation, Rep"
//			+ "\n"
//			+ "\nT has a binary relation Mgr and a unary relation SelfMgr"
//			+ "\n"
//			+ "\nM1:"
//			+ "\n"
//			+ "\n forall e, Emp(e) -> exists m, Rep(e,m)"
//			+ "\n"
//			+ "\nM2:"
//			+ "\n"
//			+ "\n forall e m, Rep(e,m) -> Mgr(e,m)"
//			+ "\n forall e, Rep(e,e) -> SelfMgr(e)"
//			+ "\n"
//			+ "\nThe composition M = M1 ; M2 is not defineable as a first-order s-t tgd,"
//			+ "\nbut is as a second-order s-t tgd:"
//			+ "\n"
//			+ "\nM:"
//			+ "\n"
//			+ "\n exists f, (forall e, Emp(e) -> Mgr(e,f(e)) /\\"
//			+ "\n           (forall e, Emp e /\\ e = f(e) -> SelfMgr(e))"
//			+ "\n"
//			+ "\n*/"
//			+ "\n"
//			+ "\nschema S = {"
//			+ "\n nodes Emp, Dom;"
//			+ "\n attributes attr : Dom -> string;"
//			+ "\n arrows f : Emp -> Dom;"
//			+ "\n equations;"
//			+ "\n}"
//			+ "\n"
//			+ "\nschema X = {"
//			+ "\n nodes Rep, Dom;"
//			+ "\n attributes attr : Dom -> string;"
//			+ "\n arrows f : Rep -> Dom, g : Rep -> Dom;"
//			+ "\n equations;"
//			+ "\n}"
//			+ "\n"
//			+ "\nschema T = {"
//			+ "\n nodes Mgr, SelfMgr, Dom;"
//			+ "\n attributes attr : Dom -> string;"
//			+ "\n arrows f : Mgr -> Dom, g : Mgr -> Dom, h : SelfMgr -> Dom;"
//			+ "\n equations;"
//			+ "\n}"
//			+ "\n"
//			+ "\ninstance I : S = {"
//			+ "\n nodes Emp -> {1,2,3}, Dom -> {a,b,c};"
//			+ "\n attributes attr -> {(a,Alice),(b,Bob),(c,Carol)};"
//			+ "\n arrows f -> {(1,a),(2,b),(3,c)};"
//			+ "\n}"
//			+ "\n"
//			+ "\n// M1 //////////////////////////////////////////////////"
//			+ "\n"
//			+ "\nmapping M1 : S -> X = {"
//			+ "\n nodes Emp -> Rep, Dom -> Dom;"
//			+ "\n attributes attr -> attr;"
//			+ "\n arrows f -> Rep.f;"
//			+ "\n}"
//			+ "\n"
//			+ "\nmapping MX : X -> X = {"
//			+ "\n nodes Rep -> Rep, Dom -> Dom;"
//			+ "\n attributes attr -> attr;"
//			+ "\n arrows f -> Rep.f;"
//			+ "\n}"
//			+ "\n"
//			+ "\n//we see that pi constructs a universal solutions to "
//			+ "\n//forall e m, Emp(e) /\\ Emp(m) -> Rep(e,m)"
//			+ "\n//i.e., if |Emp| = 3, then |Rep| = 9"
//			+ "\ninstance piM1I : X = pi M1 I"
//			+ "\n"
//			+ "\n//all attempts to use sigma fail:"
//			+ "\n"
//			+ "\n//fails - not a discrete op fibration"
//			+ "\n//instance sigmaM1I : X = sigma M1 I"
//			+ "\n"
//			+ "\n//fails - cannot SIGMA with attributes"
//			+ "\n//instance sigmaM1I : X = SIGMA M1 I"
//			+ "\n"
//			+ "\n// M2 //////////////////////////////////////////////////"
//			+ "\n"
//			+ "\nmapping M2 : X -> T = {"
//			+ "\n nodes Rep -> Mgr, Dom -> Dom;"
//			+ "\n attributes attr -> attr;"
//			+ "\n arrows f -> Mgr.f, g -> Mgr.g;"
//			+ "\n}"
//			+ "\n"
//			+ "\ninstance piM2piM1I : T = pi M2 piM1I"
//			+ "\n"
//			+ "\n"
//			+ "\nmapping M3 : T -> T = {"
//			+ "\n nodes Mgr -> SelfMgr, SelfMgr -> SelfMgr, Dom -> Dom;"
//			+ "\n attributes attr -> attr;"
//			+ "\n arrows f -> SelfMgr.h, g -> SelfMgr.h, h -> SelfMgr.h;"
//			+ "\n}"
//			+ "\n"
//			+ "\ninstance piM3piM2piM1I : T = pi M3 piM2piM1I"
//			+ "\n"
//			+ "\n//not quite right either"
//			+ "\ninstance deltaM3piM2piM1I : T = delta M3 piM2piM1I"
//			+ "\n"
//			+ "\n// M //////////////////////////////////////////////////"
//			+ "\n"
//			+ "\nmapping M : S -> T = {"
//			+ "\n nodes Emp -> Mgr, Dom -> Dom;"
//			+ "\n attributes attr -> attr;"
//			+ "\n arrows f -> Mgr.g;"
//			+ "\n}"
//			+ "\n"
//			+ "\ninstance piMI : T = pi M I"
;
}
