package fql.examples;

public class MatchExample2 extends Example {

	@Override
	public String getName() {
		return "Schema Matching 2";
	}

	@Override
	public String getText() {
		return s;
	}
	
	String s =  "\n/* Situation 1: "
			+ "\n *  We want to create a query between schema DogOwner and schema Dog"
			+ "\n *  with attribute matching:"
			+ "\n *  match {(dogatt,dname),(personatt,ownerName)}."
			+ "\n *  "
			+ "\n *  This matching is REVERSABLE, meaning we should be able to move data either way."
			+ "\n *  The Dog ~> DogOwner query will involve making up owner IDs, but this is doable with SIGMA."
			+ "\n */"
			+ "\n "
			+ "\nschema DogOwner = {"
			+ "\n	nodes dog,person;"
			+ "\n	attributes ASWRITTEN;"
			+ "\n	arrows owner:dog->person;"
			+ "\n	equations;"
			+ "\n}"
			+ "\n"
			+ "\nschema Dog = {"
			+ "\n	nodes dog;"
			+ "\n	attributes dname:dog->string,ownerName:dog->string;"
			+ "\n	arrows;"
			+ "\n	equations;"
			+ "\n}"
			+ "\n"
			+ "\n/* Situation 2:"
			+ "\n *  We want to create a query between schema UserData and schema PossibleCouple "
			+ "\n *  with attribute matching:"
			+ "\n *  match {(mname,mname),(wname,wname),(bookname,bookname)}."
			+ "\n *  This should result in a join."
			+ "\n */"
			+ "\n"
			+ "\nschema UserData = {"
			+ "\n	nodes man,woman,book;"
			+ "\n	attributes mname:man->string,wname:woman->string,bookname:book->string;"
			+ "\n	arrows mfav:man->book,wfav:woman->book;"
			+ "\n	equations;"
			+ "\n }"
			+ "\n"
			+ "\nschema PossibleCouple = {"
			+ "\n	nodes couple;"
			+ "\n	attributes mname:couple->string,wname:couple->string,bookname:couple->string;"
			+ "\n	arrows;"
			+ "\n	equations;"
			+ "\n}"
			+ "\n"
			+ "\n/* Situation 3:"
			+ "\n *  We want to create a query between schema Employee and schema Person"
			+ "\n *  with attribute matching:"
			+ "\n *  match {(last,last),(first,first)}."
			+ "\n *  It should just be a project."
			+ "\n */"
			+ "\n"
			+ "\nschema Employee = {"
			+ "\n	nodes emp,dept;"
			+ "\n	attributes first:emp->string,last:emp->string,ssn:emp->string,name:dept->string;"
			+ "\n	arrows WorksIn:emp->dept;"
			+ "\n	equations;"
			+ "\n}"
			+ "\n"
			+ "\nschema Person = {"
			+ "\n	nodes person;"
			+ "\n	attributes first:person->string,last:person->string;"
			+ "\n	arrows;"
			+ "\n	equations;"
			+ "\n}"
			+ "\n"
			+ "\n/* Situtaion 4:"
			+ "\n *  We want to create a REVERSABLE query between schema TwoColors and schema ReallyLikes"
			+ "\n *  with attribute matching:"
			+ "\n *  match {(FavColor,loves),(SecondFavColor,loves)}."
			+ "\n *  It should be a SELECT Col1=Col2 one way and a duplicate column (i.e. Delta) the other way."
			+ "\n *  "
			+ "\n *  The idea is that for a OneColorLover,"
			+ "\n *  the same color serves as both their favorite and their second favorite."
			+ "\n */"
			+ "\n"
			+ "\nschema TwoColors = {"
			+ "\n 	nodes person;"
			+ "\n 	attributes FavColor:person->string,SecondFavColor:person->string;"
			+ "\n 	arrows;"
			+ "\n 	equations;"
			+ "\n }"
			+ "\n"
			+ "\nschema ReallyLikes = {"
			+ "\n 	nodes OneColorLover;"
			+ "\n 	attributes loves:OneColorLover->string;"
			+ "\n 	arrows;"
			+ "\n 	equations;"
			+ "\n }"
			+ "\n"
			+ "\n/* Situation 5:"
			+ "\n *  We want to create a query between schema MenAndWomen and schema PersonHome"
			+ "\n *  with attribute matching:"
			+ "\n *  match {(mfirst,first),(wfirst,first),(mlast,last),(wlast,last),(address,address)}"
			+ "\n *  This should be a simple sigma."
			+ "\n */"
			+ "\n"
			+ "\nschema MenAndWomen = {"
			+ "\n	nodes man,woman,home;"
			+ "\n	attributes "
			+ "\n		mfirst:man->string,"
			+ "\n		wfirst:man->string,"
			+ "\n		mlast:woman->string,"
			+ "\n		wlast:woman->string,"
			+ "\n		address:home->string;"
			+ "\n	arrows "
			+ "\n		mLivesAt:man->home,"
			+ "\n		wLivesAt:woman->home;"
			+ "\n	equations;"
			+ "\n}"
			+ "\n"
			+ "\nschema PersonHome = {"
			+ "\n	nodes person,home;"
			+ "\n	attributes "
			+ "\n		first:person->string,"
			+ "\n		last:person->string,"
			+ "\n		address:home->string;"
			+ "\n	arrows"
			+ "\n		LivesAt:person->home;"
			+ "\n	equations;"
			+ "\n}"
			+ "\n"
			+ "\n/* Situation 6:"
			+ "\n *  We want to create a query between the schemas presented in Madhavan, Bernstein, Rahm 2001."
			+ "\n *  The matching is:"
			+ "\n *  match{("
			+ "\n */"
			+ "\n"
			+ "\nschema MBR1 = {"
			+ "\n	nodes "
			+ "\n		PO,"
			+ "\n		POShipTo,POBillTo,POLines,"
			+ "\n		Item"
			+ "\n		;"
			+ "\n	attributes"
			+ "\n		City1:POShipTo->string,"
			+ "\n		Street1:POShipTo->string,"
			+ "\n		City2:POBillTo->string,"
			+ "\n		Street2:POBillTo->string,"
			+ "\n		Count:POLines->int,"
			+ "\n		Line:Item->string,"
			+ "\n		Qty:Item->int,"
			+ "\n		UoM:Item->string"
			+ "\n		;"
			+ "\n	arrows"
			+ "\n		ship:PO->POShipTo,"
			+ "\n		bill:PO->POBillTo,"
			+ "\n		line:PO->POLines,"
			+ "\n		item:POLines->Item"
			+ "\n		;"
			+ "\n	equations;"
			+ "\n}"
			+ "\n"
			+ "\nschema MBR2 = {"
			+ "\n	nodes "
			+ "\n		PurchaseOrder,"
			+ "\n		Items,DeliverTo,InvoiceTo,"
			+ "\n		Item,DeliverAddress,InvoiceAddress"
			+ "\n		;"
			+ "\n	attributes"
			+ "\n		City1:DeliverAddress->string,"
			+ "\n		Street1:DeliverAddress->string,"
			+ "\n		City2:InvoiceAddress->string,"
			+ "\n		Street2:InvoiceAddress->string,"
			+ "\n		ItemCount:Items->int,"
			+ "\n		ItemNumber:Item->string,"
			+ "\n		Quantity:Item->int,"
			+ "\n		UnitofMeasure:Item->string"
			+ "\n		;"
			+ "\n	arrows"
			+ "\n		deliver:PurchaseOrder->DeliverTo,"
			+ "\n		invoice:PurchaseOrder->InvoiceTo,"
			+ "\n		items:PurchaseOrder->Items,"
			+ "\n		item:Items->Item,"
			+ "\n		deliverAdd:DeliverTo->DeliverAddress,"
			+ "\n		invoiceAdd:InvoiceTo->InvoiceAddress"
			+ "\n		;"
			+ "\n	equations;"
			+ "\n}";




}
