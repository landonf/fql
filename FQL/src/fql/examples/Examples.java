package fql.examples;

/**
 * 
 * @author ryan
 * 
 *         This class contains the text of the hard-coded demo examples and help
 *         dialog.
 */
public class Examples {

	public static Example plusSig = new CoProdExample();
	public static Example plusSig2 = new CoProducts2Example();
	public static Example full = new FullSigmaExample();
	public static Example external = new ExternalExample();
	public static Example people = new PeopleExample();
	public static Example typedFoil = new TypedFoilExample();
	public static Example typedPi = new TypedPiExample();
	public static Example typedWeird = new TypedWeirdExample();
	public static Example weird = new WeirdExample();
	public static Example sql2fql = new SqlToFqlExample();
	public static Example foil = new FoilExample();
	public static Example empty = new EmptyExample();
	public static Example typeddelta = new TypedDeltaExample();
	public static Example delta = new DeltaExample();
	public static Example pi = new PiExample();
	public static Example sigma = new SigmaExample();
	public static Example composition = new CompositionExample();
	public static Example tcomp = new TypedCompositionExample();
	public static Example iso = new IsoExample();
	public static Example triangle = new TriangleExample();
	public static Example cyclicgroup = new CyclicExample();
	public static Example employess = new EmployeesExample();
	public static Example dihedral = new DihedralExample();
	public static Example typedemployees = new TypedEmployeesExample();
	public static Example typedsigma = new TypedSigmaExample();
	public static Example relative = new RelationalizerExample();
	public static Example sotgd = new EDExample();
	public static Example products = new ProductExample();
	public static Example products2 = new Product2Example();
	
	public static Example transform = new TransformExample();
	public static Example transform2 = new Transforms2Example();
	public static Example written = new WrittenExample();
	public static Example monad = new MonadExample();
	public static Example gene = new GeneExample();

	public static Example[] examples = new Example[] { people, external, plusSig2, products2,
			typeddelta, delta, pi, typedPi, typedsigma, sigma, full, employess,
			typedemployees, composition, tcomp, iso, triangle, cyclicgroup, transform2,
			dihedral, empty, foil, typedFoil, sql2fql, weird, written, monad,
			typedWeird, relative, sotgd, plusSig, products, transform, gene };


	public static final String helpString = "See the People example for a tutorial, and the All Syntax example for all possible FQL syntax."
			+ "\n"
			+ "\nFor many purposes, signatures must be finite (see options)."
			+ "\n"
			+ "\nFQL is not case-sensitive, but many SQL systems are."
			+ "\n"
			+ "\nCREATE TABLE statements generated by instances can be suppressed using the keyword \"external\"," 
			+ "\nand results dropped using the \"drop\" command. (see External example)."
			+ "\n"
			+ "\nInstance values must be single words, unless they are quoted."
			+ "\n"
			+ "\nMany features are disabled in applets, such as copy/paste,save, all menu items."
			+ "\n" 
			+ "\nTry Control-shift-space after schema, instance, mapping, query for code completion. "
			+ "\n"
			+ "\nNested instance expressions (e.g., A+B+C) must have explicitly named sub-expressions."
			+ "\nThis is necessary because the SQL generated by instance declarations is effectful."
			+ "\nAs a corollary, instance equality in the transform typing rules is nominal, not structural."
			+ "\n"
			+ "\nProject webpage: wisnesky.net/fql.html\n"
			+ "\n -- Typing rules ------------ \n"
			+ "\nid C : C -> C"
			+ "\nf then g : A -> C when f : A -> B and g : B -> C"
			+ "\nvoid C : void -> C"
			+ "\ninl A B : A -> A + B"
			+ "\ninr A B : B -> A + B"
			+ "\nf + g : A + B -> C when f : A -> C and g : B -> C"
			+ "\nunit C : C -> unit"
			+ "\nfst A B : A * B -> A"
			+ "\nsnd A B : A * B -> B"
			+ "\nf * g : A -> B * C when f : A -> B and g : A -> C"
			+ "\neval A B : (A ^ B) * B -> A"
			+ "\ncurry f : A -> C ^ B when f : A * B -> C"
			+ "\n"
			+ "\ndelta F I : S when F : S -> T and I : T"
			+ "\nsigma F I : T when F : S -> T and I : S"
			+ "\npi F I : T when F : S -> T and I : S"
			+ "\nrelationalize I : S when I : S"
			+ "\nexternal C name : C"
			+ "\nI + J : S when I : S and J : S"
			+ "\nI * J : S when I : S and J : S"
			+ "\nI ^ J : S when I : S and J : S"
			+ "\nunit S : S "
			+ "\nvoid S : S "
			+ "\n"
			+ "\ndelta F pi G sigma H : S -> T when F : U -> S and G : U -> W and H : W -> T\n";

}
