package fql.examples;


/**
 * 
 * @author ryan
 * 
 *         This class contains the text of the hard-coded demo examples and help
 *         dialog.
 */
public class Examples {

	public static Example exp = new ExponentialExample();
	public static Example graph = new GraphExample();
	public static Example plusSig = new CoProdExample();
	public static Example full = new FullSigmaExample();
	public static Example full2 = new FullSigmaExample2();
	public static Example external = new ExternalExample();
	public static Example people = new PeopleExample();
	public static Example typedFoil = new TypedFoilExample();
	public static Example typedPi = new TypedPiExample();
	public static Example typedWeird = new TypedWeirdExample();
	public static Example sql2fql = new SqlToFqlExample();
	public static Example empty = new EmptyExample();
	public static Example typeddelta = new DeltaExample();
	public static Example tcomp = new TypedCompositionExample();
	public static Example iso = new IsoExample();
	public static Example triangle = new TriangleExample();
	public static Example cyclicgroup = new CyclicExample();
	public static Example employess = new EmployeesExample(); 
	public static Example dihedral = new DihedralExample();
	public static Example typedemployees = new TypedEmployeesExample();
	public static Example typedsigma = new TypedSigmaExample();
	public static Example relative = new RelationalizerExample();
	public static Example products = new ProductExample();
	public static Example enums = new EnumsExample();
	// public static Example functor = new FunctorExample();
	public static Example transform = new TransformExample();
	public static Example transform2 = new Transforms2Example();
	public static Example written = new WrittenExample();
//	public static Example monad = new MonadExample();
	public static Example gene = new GeneExample();
	public static Example sub = new SubSchemaExample();
	public static Example match = new MatchExample();
	public static Example match2 = new MatchExample2();
	public static Example surj = new SurjectiveExample();
	public static Example cat = new CategoryExample();
	public static Example eds2fql = new EDsToFqlExample();
	public static Example fncomp = new FnCompExample();
	
	public static Example[] examples = new Example[] { exp, fncomp, graph, eds2fql, cat, surj,
			full2, match2, match, sub, /* functor, */enums, people,
			external, typeddelta, /* delta, pi, */ typedPi,
			typedsigma,  /* sigma, */  full, employess, typedemployees, /* composition, */
			tcomp, iso, triangle, cyclicgroup, transform2, dihedral, empty,
			/* foil, */ typedFoil, sql2fql, /* weird, */ written, /* monad, */ typedWeird,
			relative, plusSig, products, transform, gene };
	
	public static Example[] key_examples = new Example[] {  exp, surj,
		 enums, people,
		external, typeddelta, typedPi,
		typedsigma, full, typedemployees, 
		tcomp, empty,
		 typedFoil, sql2fql, 
		relative, plusSig, products, transform, gene };


	public static final String helpString = "See the People example for a tutorial, and the All Syntax example for all possible FQL syntax.  Additional examples can be enabled by unchecking the 'show only limited examples' box in the viewer panel of the options menu."
			+ "\n"
			+ "\nFor many purposes, signatures must be finite.  Support for some infinite signatures and migrations can be enabled in the options menu."
			+ "\n"
			+ "\nCREATE TABLE statements generated by instances can be suppressed using the keyword \"external\","
			+ "\nand results dropped using the \"drop\" command. (see External example)."
			+ "\n"
			+ "\nInstance values must be single words, unless they are quoted.  Negative numbers must be quoted."
			+ "\n"
			+ "\nFQL is case insensitive."
			+ "\n"
			+ "\nTry Control-shift-space after schema, instance, mapping, query, transform for code completion. "
			+ "\n"
			+ "\nNested instance expressions (e.g., A+B+C) must have explicitly named sub-expressions."
			+ "\nThis is necessary because the SQL generated by instance declarations is effectful."
			+ "\nAs a corollary, instance equality in the transform typing rules is nominal, not structural."
			+ "\nIn addition, SIGMA transforms must refer to named transforms as input, so that FQL can"
			+ "\nimplement it even if it can't be via JDBC."
			+ "\n"
			+ "\nIf using mysql, note that certain column names are prohibited -- like \"left\", \"right\", and \"limit\"."
			+ "\n"
			+ "\nIf your program is taking too long to run, try disabling the observables and elements GUI panes in the options menu.  Use Abort in the tools menu to stop long-running computations."
			+ "\n"
			+ "\nRDF output will not quote brackets or slashes or quotes, so certain input strings can cause the RDF output to be ill-formed."
			+ "\n"
			+ "\nProject webpage: categoricaldata.net"
			+ "\n"
			+ "\n -- Typing rules ------------ \n"
			+ "\nid C : C -> C"
			+ "\nf then g : A -> C when f : A -> B and g : B -> C"
			+ "\nvoid C : void -> C"
			+ "\ninl A B : A -> A + B"
			+ "\ninr A B : B -> A + B"
			+ "\nf + g : A + B -> C when f : A -> C and g : B -> C"
			+ "\nunit C : C -> unit"
			+ "\nfst A B : A * B -> A"
			+ "\nsnd A B : A * B -> B"
			+ "\nf * g : A -> B * C when f : A -> B and g : A -> C"
			+ "\neval A B : (A ^ B) * B -> A"
			+ "\ncurry f : A -> C ^ B when f : A * B -> C"
			+ "\n"
			+ "\ndelta F I : S when F : S -> T and I : T"
			+ "\nsigma F I : T when F : S -> T and I : S"
			+ "\npi F I : T when F : S -> T and I : S"
			+ "\nrelationalize I : S when I : S"
			+ "\nexternal C name : C"
			+ "\nI + J : S when I : S and J : S"
			+ "\nI * J : S when I : S and J : S"
			+ "\nI ^ J : S when I : S and J : S"
			+ "\nunit S : S "
			+ "\nvoid S : S "
			+ "\n"
			+ "\ndelta F pi G sigma H : S -> T when F : U -> S and G : U -> W and H : W -> T"
			+ "\n"
			+ "\nreturn : I -> delta(sigma(I)) "
			+ "\nreturn : I -> pi(delta(I))"
			+ "\ncoreturn : sigma(delta(I)) -> I"
			+ "\ncoreturn : delta(pi(I)) -> I"
			;

}
