package fql.examples;


public class SqlToFqlExample extends Example {

	@Override
	public String getName() {
		return "SQL to FQL";
	}

	@Override
	public String getText() {
		return s;
	}

	String s= "/* Ryan's query, written in David's best SQL (See Ryan's original request at bottom of file):"
			+ "\n *  "
			+ "\n *  SELECT A.c1, C.c5, C.c6 "
			+ "\n *  FROM A,B,C"
			+ "\n *  WHERE A.c1=B.c2 AND B.c3=C.c4 AND C.c5=C.c6"
			+ "\n *  "
			+ "\n *  "
			+ "\n */"
			+ "\n"
			+ "\n"
			+ "\n"
			+ "\nschema First ={"
			+ "\n nodes A, B, C, X, Y, Z;"
			+ "\n attributes;"
			+ "\n arrows"
			+ "\n 	c1:A->X,"
			+ "\n 	c2:B->X,"
			+ "\n 	c3:B->Y,"
			+ "\n 	c4:C->Y,"
			+ "\n 	c5:C->Z,"
			+ "\n 	c6:C->Z;"
			+ "\n equations;"
			+ "\n}"
			+ "\n"
			+ "\nschema Intermediate = {"
			+ "\n nodes ABC, X, Y, Z;"
			+ "\n attributes;"
			+ "\n arrows"
			+ "\n 	c12:ABC->X,"
			+ "\n 	c34:ABC->Y,"
			+ "\n 	c56:ABC->Z;"
			+ "\n equations;"
			+ "\n}"
			+ "\n"
			+ "\nschema Last = {"
			+ "\n nodes ABC, X, Z;"
			+ "\n attributes;"
			+ "\n arrows"
			+ "\n 	c12:ABC->X,"
			+ "\n 	c561:ABC->Z,"
			+ "\n 	c562:ABC->Z;"
			+ "\n equations;"
			+ "\n}"
			+ "\n"
			+ "\nmapping F:First->Intermediate = { //To pi along for joins and selects "
			+ "\n nodes"
			+ "\n 	A->ABC,"
			+ "\n 	B->ABC, "
			+ "\n 	C->ABC,"
			+ "\n 	X->X,"
			+ "\n 	Y->Y,"
			+ "\n 	Z->Z;"
			+ "\n attributes;"
			+ "\n arrows"
			+ "\n 	c1->ABC.c12,"
			+ "\n 	c2->ABC.c12,"
			+ "\n 	c3->ABC.c34,"
			+ "\n 	c4->ABC.c34,"
			+ "\n 	c5->ABC.c56,"
			+ "\n 	c6->ABC.c56;"
			+ "\n} First Intermediate"
			+ "\n"
			+ "\nmapping G:Last->Intermediate = { //To Delta along, for projects "
			+ "\n nodes "
			+ "\n 	ABC->ABC,"
			+ "\n 	X->X,"
			+ "\n 	Z->Z;"
			+ "\nattributes;"
			+ "\narrows"
			+ "\n 	c12->ABC.c12,"
			+ "\n	c561->ABC.c56,"
			+ "\n 	c562->ABC.c56;"
			+ "\n} Last Intermediate"
			+ "\n"
			+ "\ninstance I : First = {"
			+ "\n nodes"
			+ "\n 	A -> {A1,A2},"
			+ "\n 	B -> {B1,B2,B3},"
			+ "\n 	C -> {C1,C2,C3},"
			+ "\n 	X -> {X1,X2},"
			+ "\n 	Y -> {Y1,Y2},"
			+ "\n 	Z -> {Z1,Z2,Z3};"
			+ "\n attributes;"
			+ "\n arrows"
			+ "\n 	c1 -> {(A1,X1),(A2,X2)},"
			+ "\n 	c2 -> {(B1,X1),(B2,X1),(B3,X2)},"
			+ "\n 	c3 -> {(B1,Y1),(B2,Y2),(B3,Y2)},"
			+ "\n 	c4 -> {(C1,Y1),(C2,Y2),(C3,Y1)},"
			+ "\n 	c5 -> {(C1,Z1),(C2,Z2),(C3,Z1)},"
			+ "\n 	c6 -> {(C1,Z1),(C2,Z2),(C3,Z1)};"
			+ "\n /* Alternate 1:  c6={(C1,Z1),(C2,Z1),(C3,Z2)}."
			+ "\n    Alternate 2:  c6={(C1,Z2),(C2,Z2),(C3,Z1)}*/ "
			+ "\n} First"
			+ "\n"
			+ "\ninstance Pi_FI : Intermediate = pi F I"
			+ "\n"
			+ "\ninstance Delta_GPi_FI : Last = delta G Pi_FI  // Result "
			+ "\n"
			+ "\n"
			+ "\n"
			+ "\n"
			+ "\n/* Ryan's request: "
			+ "\n * Here's the example I'd like to translate to FQL"
			+ "\n * Start with three input relations:"
			+ "\n *"
			+ "\n * A(c1)"
			+ "\n * B(c2,c3)"
			+ "\n * C(c4,c5,c6)"
			+ "\n *"
			+ "\n * Product A with B with C"
			+ "\n * filter for A.c1 = B.c2 and B.c3 = C.c4 and C.c5 = C.c6"
			+ "\n * project out A.c1 and C.c5 and C.c6"
			+ "\n */";
}
